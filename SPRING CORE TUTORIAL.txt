SPRING CORE TUTORIAL:

Softwares:
1) Eclipse/Netbeans/IntelliJ
2) TomcatServer
3) MySQL for Database
4) MySQL Workbench (GUI any)

---------------------------------------------------------------------------------------------------

Basics:
1) Create a maven project
2) Add dependencies -> spring core, spring context (from online maven repo to pom.xml)
3) creating beans - java pojo (plain old java object)
4) creating configuration file -> config.xml
5) setter Injection
6) Main class: which can pull the object and use

---------------------------------------------------------------------------------------------------

DEPENDENCY INJECTION TYPES:
Primitive Types:
<property name="">
    <value>value</value>
</property>

<property name="" value="" />

<bean class="" name="" p:propertyname="" /> (P Schema)

Collection Types:

List, Set
<bean>
    <property name="">
        <list> (name according to collection used)
	    <value>10</value>
            <value>100</value>
	    <null/> (for null values)
            ...
	</list>
    </property>
</bean>

Map
<bean>
    <property name="">
        <map> (name according to collection used)
	    <entry key="java" value="2month" />
	    <entry key="python" value="1month" />
            ...
	</map>
    </property>
</bean>

Properties
<bean>
    <property name="">
	<props>
	    <prop key="name">Bharateesh</prop>
	    <prop key="channelName">Bharateesh Ananth</prop>
	</props>
    </property>
</bean>

Reference Type:
A
Reference Inject:
B

<bean>
    <property name="a">
	<ref bean="b" />
    </property>
</bean>

---------------------------------------------------------------------------------------------------
Constructor Injection:

<bean class="com.springcore.ci.Person" id="p1">
    	<constructor-arg>
    		<value>Bharateesh</value>
    	</constructor-arg>
</bean>

<bean class="com.springcore.ci.Person" id="p1">
    	<constructor-arg value="bharateesh" />
    	<constructor-arg value="018" />
</bean>

c-schema:
<bean class="com.springcore.ci.Cert" name="cert" c:name="Python Language" />

---------------------------------------------------------------------------------------------------
Constructor Injection - Ambiguity Problem Fix:

<bean class="com.springcore.ci.Addition" id="add">
    	<constructor-arg value="12" type="int" index="1"/>
    	<constructor-arg value="34" type="int" index="0"/>
</bean>

---------------------------------------------------------------------------------------------------
Bean Life-Cycle Methods:
it has basically init() and destroy() methods given to a bean.
Tested it accordingly by xml, interfaces or annotations
object creation(Bean) -> init -> access bean methods -> destroy
Eg:

xml config:
<bean class="com.springcore.lifecycle.Samosa" id="s1" init-method="init" destroy-method="destroy">
    	<property name="price" value="15" />
</bean>
in Main:
AbstractApplicationContext context = new ClassPathXmlApplicationContext("com/springcore/lifecycle/config.xml");
context.registerShutdownHook(); (Required to catch destroy method results)

Using Interfaces:
InitializingBean(init), DisposableBean(destroy) (implement in bean class)
Remember Bean Initializing and destroction order accordingly.

Using Annotations:
@PostConstruct and @PreDestroy annotations used. (Deprecated after Java9, import as a dependency in pom.xml)
Enable annotation in config file using: <context:annotation-config></context:annotation-config> 
---------------------------------------------------------------------------------------------------
Autowiring: To automatically do dependency injection of object references.

XML:
First create referring class, by basic property or constructor injection.
Next create calling class, then add autowire property in the tag adding one of the modes based on requirements:
byName, byType, coinstructor (other: default,no)

Annotations:
Here we can use below annotations:
@Autowired
@Qualifier("bean name/id")

---------------------------------------------------------------------------------------------------
Standalone Collections:

We can specify what type of collection we want using util schema. In xml add these tags:
xmlns:util="http://www.springframework.org/schema/util"
http://www.springframework.org/schema/util
    http://www.springframework.org/schema/util/spring-util.xsd
    "(at end)

and make a tag outside any bean for collection u want:
<util:list list-class="java.util.LinkedList" id="mybestfriends">
    	<value>Rakshith</value>
    	<value>Pavan</value>
    	<value>Shashidhar</value>
</util:list>

and call the above using ref tag in xml:
<bean class="com.springcore.standalone.collections.Person" name="p1">
    	<property name="friends">
    		<ref bean="mybestfriends" />
    	</property>
</bean>

---------------------------------------------------------------------------------------------------
Stereotype Annotations:
To create <bean></bean> without xml using annotations way.

@Component & @Component(""): Default-camelcase classname object, if set-your object name
in xml add:
<context:component-scan base package=""/>
and use the above annotation on called class

to add values, use @Value("") annotation above the declaration of variables.

@Value("") for collections:
- Make a standalone collection in xml as discussed earlier.
- @Value("#{ADD YOUR COLLECTION's REF ID/NAME}")

---------------------------------------------------------------------------------------------------
Bean Scope:

- Singleton:
use hashCode() for object in main function. We observe it gives same hashcode for same two objects, it's called as a singleton scope - default mode is singleton.
We can configure bean scope either using xml file or annotation.
In xml, we add scope="" attribute in bean tag.
In annotation, we use @Component along with @Scope("") before the class definition.
- Prototype:
Opposite of latter.
Request:for web
Session:for web
globalsession:for web, for portlet applications

---------------------------------------------------------------------------------------------------
Spring Expression Language (SpEL):
- For Parsing and executing annotations with @Value annotation.
- format: @Value("# {ANY EXPRESSION HERE}") - Expression Passables: Class, Variables, Methods, Symbols, Objects, static methods etc. It will resolve.
- Examples: @Value("#{11+22}")
	    @Value("#{8>6?true:false}")
- Examples for invoking class methods & Variables: T(class).method(param)
			Example: T(java.lang.Math).sqrt(4)
			Example: T(java.lang.Integer).Max_Value -> for variables
- Examples for  creating objects: new Object(value) (for constructors)
			Example: @Value({new String('BCA')})
